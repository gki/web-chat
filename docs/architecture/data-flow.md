# データフロー・リアルタイム通信設計

## 実現すべきポイント

### データフローの基本要求
- **単一方向性**: クライアント→サーバー→クライアントの明確なデータフロー
- **イベント駆動**: 状態変更を即座に全クライアントへ伝播
- **データ整合性**: 全てのクライアント間でのデータ一貫性維持
- **効率的配信**: 必要なクライアントへの選択的データ配信

### データ整合性要求
- **永続化**: メッセージ・ユーザー情報の確実なデータベース保存
- **トランザクション**: 複数操作の原子性保証
- **同期**: クライアントキャッシュとサーバー状態の整合性維持
- **復旧**: 接続断絶時のデータ補完と状態復元

## 選択の背景・理由

### データフロー設計の基本方針

リアルタイム通信の具体的な要求事項については[リアルタイム更新機能要件](../requirements/functional/real-time-updates.md)を、
技術スタックの選択理由については[技術スタック選定](./tech-stack.md)を参照。

### イベント駆動型アーキテクチャ採用の理由

- **疎結合設計**: イベント発行者と購読者の独立性による保守性向上
- **拡張性確保**: 新しいイベントタイプの追加が既存システムに影響しない
- **効率的配信**: 必要なクライアントのみへの選択的イベント配信
- **障害隔離**: 一部クライアント障害が全体システムに波及しない設計

クライアント側の状態管理戦略については[状態管理（Apollo Client）](../frontend/state-management.md)を参照。

### PubSubエンジン選択

#### インメモリPubSub採用の理由
- **シンプル性**: 単一サーバー構成での実装簡潔性
- **パフォーマンス**: メモリ内処理による低遅延
- **開発効率**: 外部依存なしでの迅速プロトタイピング
- **移行容易性**: 将来的なRedis PubSub移行の実現可能性

## 検討した代替案と却下理由

### データフロー設計の代替案

#### RESTful API + WebSocket分離型
- **長所**: 明確な責務分離、既存のREST知識活用
- **短所**: 二重のAPI管理、型定義の重複、統合的なキャッシュ管理困難
- **却下理由**: GraphQLによる統一的なデータフロー管理の優位性

#### イベントソーシング型アーキテクチャ
- **長所**: 完全な監査証跡、時系列でのデータ再現可能性
- **短所**: 実装複雑性、ストレージコスト、学習曲線
- **却下理由**: 現在のアプリケーション要求に対して過剰な複雑性

通信プロトコルの代替案については[リアルタイム更新機能要件](../requirements/functional/real-time-updates.md)を、
状態管理の代替案については[状態管理（Apollo Client）](../frontend/state-management.md)を参照。

## 将来への影響・考慮事項

### データフロー観点での将来課題

#### メッセージ配信の保証レベル
- **現在**: ベストエフォート型配信（インメモリPubSub）
- **将来**: At-least-once配信保証の必要性
- **対策**: メッセージキューシステムの導入検討

#### データフローの可視化・監視
- **課題**: リアルタイムデータフローの追跡困難性
- **必要性**: 問題発生時の原因特定・デバッグ
- **対策**: 分散トレーシングシステムの導入

スケーラビリティの詳細については[スケーラビリティ設計](../requirements/non-functional/scalability.md)を、
パフォーマンス最適化については[パフォーマンス要件](../requirements/non-functional/performance.md)を、
セキュリティ考慮事項については[セキュリティ要件](../requirements/non-functional/security.md)を参照。